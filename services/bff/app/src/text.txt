export async function validateCredentials(username: string, password: string): Promise<Response> {
	const url = 'http://account:3000/internal/accounts/login';
	return fetch(url, {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({ username, password })
	});
}

export async function updateAccountUsername(userID: number, newUsername: string): Promise<Response> {
	const url = `http://account:3000/internal/accounts/${userID}/username`;
	return fetch(url, {
		method: 'PATCH',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({ newUsername })
	});
}

export async function updateAccountPassword(userID: number, newHashedPassword: string): Promise<Response> {
	const url = `http://account:3000/internal/accounts/${userID}/password`;
	return fetch(url, {
		method: 'PATCH',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({ newHashedPassword })
	});
}

export async function updateUserProfileUsername(userID: number, newUsername: string): Promise<Response> {
	const url = `http://users:3000/internal/users/${userID}/username`;
	return fetch(url, {
		method: 'PATCH',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({ newUsername })
	});
}import type { UserData } from './gateway.interface.js';
import type { RawFriend } from './gateway.interface.js';
import type { UserProfile } from './gateway.interface.js';

export async function findUserByUsername(username: string): Promise<UserData | null> {
	const response = await fetch(`http://users:3000/internal/users/by-username/${username}`);

	if (response.status === 404)
		return (null);

	if (!response.ok)
		throw (new Error('Users service failed.'));

	return (response.json() as Promise<UserData>);
}

export async function createFriendRequest(senderID: number, friendID: number): Promise<Response> {
	return (fetch('http://friends:3000/internal/friends/sendrequest', {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({ senderID, friendID })
	}));
}

export async function acceptFriendRequest(senderRequestID: number, friendID: number): Promise<Response> {
	return (fetch('http://friends:3000//internal/friends/acceptrequest', {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({ senderRequestID, friendID })
	}));
}

export async function deleteFriendRequest(removerID: number, friendID: number): Promise<Response> {
	return (fetch('http://friends:3000//internal/friends/deletefriendship', {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({ removerID, friendID })
	}));
}

export async function fetchRawFriends(userID: number): Promise<RawFriend[]> {
	const response = await fetch(`http://friends:3000/internal/users/${userID}/friends`);

	if (!response.ok)
		throw (new Error('Friends service failed.'));

	return (response.json() as Promise<RawFriend[]>);
}

export async function fetchRawFriendRequests(userID: number): Promise<RawFriend[]> {
	const response = await fetch(`http://friends:3000/internal/users/${userID}/friend-requests`);

	if (!response.ok)
		throw (new Error('Friends service failed.'));

	return (response.json() as Promise<RawFriend[]>);
}

export async function fetchUserProfiles(userIDs: number[]): Promise<UserProfile[]> {
	if (userIDs.length === 0)
		return [];

	const response = await fetch('http://users:3000/internal/users/profiles-by-ids', {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({ userIDs })
	});

	if (!response.ok)
		throw (new Error('Users service failed.'));

	return (response.json() as Promise<UserProfile[]>);
}
export type ProfileView = 'self' | 'friend' | 'pending' | 'stranger';
export type StatusUser = 'offline' | 'online' | 'in-game';

export interface UserCard {
	id: number;
	username: string;
	avatar: string;
	biography: string;
	winstreak: number;
	status: StatusUser
	relation: ProfileView;
}

export interface RawUserProfile {
	userID: number;
	username: string;
	avatar: string;
	biography: string;
}

export interface RawUserStats { winStreak: number; }
export interface RawUserActivity { activityStatus: StatusUser; }
export interface FriendshipStatus { status: ProfileView; }

export interface UserData {
	userID: number;
	username: string;
}

export interface RawFriend {
	otherUserID: number;
	startTime: string;
}

export interface UserProfile {
	userID: number;
	username: string;
	avatar: string;
	biography: string;
	profileColor: string;
	rank: number;
}

export interface FriendProfileCard {
	username: string;
	avatar: string;
	biography: string;
	//TODO: complete with all the profile card parameters
	friendship: {
		friendsSince: string;
	};
}

export async function fetchUserStats(userID: number): Promise<Response> {
	const url = `http://users:3000/internal/users/${userID}/stats`;
	return fetch(url);
}

export async function updateUserStats(userID: number, statsData: object): Promise<Response> {
	const url = `http://users:3000/internal/users/${userID}/stats`;
	return fetch(url, {
		method: 'PATCH',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify(statsData)
	});
}

export async function incrementWinStreak(userID: number): Promise<Response> {
	const url = `http://users:3000/internal/users/${userID}/stats/win-streak/increment`;
	return fetch(url, {
		method: 'POST'
	});
}

export async function resetWinStreak(userID: number): Promise<Response> {
	const url = `http://users:3000/internal/users/${userID}/stats/win-streak/reset`;
	return fetch(url, {
		method: 'POST'
	});
}
import type { FriendshipStatus } from "./gateway.interface.js";
import type { RawUserActivity } from "./gateway.interface.js";

//TODO :code the friend internal route
export async function fetchFriendshipStatus(userA: number, userB: number): Promise<FriendshipStatus> {
	const response = await fetch(`http://friends:1616/internal/relationship?userA=${userA}&userB=${userB}`);
	if (!response.ok)
		return { status: 'stranger' };
	return (response.json() as Promise<FriendshipStatus>);
}

export async function fetchUserActivityStatus(userID: number): Promise<RawUserActivity> {
	const response = await fetch(`https://user:2626/internal/users/activity/${userID}`);
	if (!response.ok)
		throw new Error(`Users service failed with status: ${response.status}`);
	return response.json() as Promise<RawUserActivity>;
}

export async function updateUserProfileField(userID: number, field: string, value: any): Promise<Response> {
	const url = `http://users:3000/internal/users/${userID}/${field}`;
	return fetch(url, {
		method: 'PATCH',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({ "value": value })
	});
}

//TODO :
//export async function fetchUserProfile(userID: number): Promise<RawUserProfile | null> { }

//TODO: 
//export async function findUserByUsername(username: string): Promise<{ userID: number } | null> { /* ... */ }

import type { FastifyInstance } from 'fastify';

async function fetchTranslation(word: string, langCode: string): Promise<Response> {
	const url = `http://accessibility-service:3000/internal/translations?word=${encodeURIComponent(word)}&langCode=${encodeURIComponent(langCode)}`;
	return (fetch(url));
}

export async function gatewayAccessibilityRoutes(serv: FastifyInstance) {

	serv.get('/api/translations', async (request, reply) => {
		try {
			const { word, lang } = request.query as { word: string, lang: string };

			if (!word || !lang)
				return reply.code(400).send({ message: 'Missing required query parameters: word, lang' });

			const translationResponse = await fetchTranslation(word, lang);
			return (reply
				.code(translationResponse.status)
				.send(await translationResponse.json()));

		} catch (error) {
			serv.log.error(`[BFF] Error getting translation: ${error}`);
			return (reply.code(503).send({ message: 'The translation service is currently unavailable.' }));
		}
	});
}import type { FastifyInstance } from 'fastify';
import type { UserData } from './gateway.interface.js';

import * as bcrypt from 'bcrypt';
import * as jwt from 'jsonwebtoken';
import { validateCredentials } from './gatewayAccount.service.js';
import { updateAccountUsername } from './gatewayAccount.service.js';
import { updateAccountPassword } from './gatewayAccount.service.js';
import { updateUserProfileUsername } from './gatewayAccount.service.js';

//TODO: find a secure way to handle JWT_SECRET
const JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-and-long-key-for-development';

/*
//Install the dotenv package
npm install dotenv

// At the very top of your main server file
import 'dotenv/config';

// Now, process.env is populated with variables from your .env file
const JWT_SECRET = process.env.JWT_SECRET;

// You can now use this variable throughout your file
console.log(`Successfully loaded JWT_SECRET: ${JWT_SECRET}`);

// --- Example of using it in your code ---
import * as jwt from 'jsonwebtoken';

// ... inside a function
const payload = { userID: 123 };
const token = jwt.sign(payload, JWT_SECRET, { expiresIn: '1h' });
*/

export async function gatewayAccountRoutes(serv: FastifyInstance) {

	serv.post('/account/login', async (request, reply) => {
		try {
			const { username, password } = request.body as { username: string, password: string };

			const validationResponse = await validateCredentials(username, password);

			if (!validationResponse.ok)
				return reply.code(validationResponse.status).send({ message: 'Invalid credentials.' });

			const UserData = await validationResponse.json() as UserData;

			const payload = { userID: UserData.userID, username: UserData.username };
			const token = jwt.sign(payload, JWT_SECRET, { expiresIn: '1h' });

			return reply.code(200).send({ token: token });
		} catch (error) {
			serv.log.error(`[BFF] Login error: ${error}`);
			return reply.code(503).send({ message: 'A backend service is unavailable.' });
		}
	});

	serv.patch('/account/username', async (request, reply) => {
		let isAuthUpdated = false;
		const userID = request.user.userID;
		const oldUsername = request.user.username;
		const { newUsername } = request.body as { newUsername: string };

		try {
			const accountResponse = await updateAccountUsername(userID, newUsername);

			if (!accountResponse.ok)
				return reply.code(accountResponse.status).send(await accountResponse.json());
			isAuthUpdated = true;

			const profileResponse = await updateUserProfileUsername(userID, newUsername);

			if (!profileResponse.ok)
				throw new Error('Profile service update failed.');

			return reply.code(200).send({ message: 'Username updated successfully.' });

		} catch (error) {
			serv.log.error(`[BFF] Username update error: ${error}`);

			if (isAuthUpdated) {
				serv.log.warn(`Rolling back username change for userID: ${userID}`);
				await updateAccountUsername(userID, oldUsername);
			}
			return reply.code(503).send({ message: 'A backend service failed during username update.' });
		}
	});

	serv.patch('/account/password', async (request, reply) => {
		try {
			const userID = request.user.userID;
			const { newPassword } = request.body as { newPassword: string };

			const newHashedPassword = await bcrypt.hash(newPassword, 10);

			const response = await updateAccountPassword(userID, newHashedPassword);

			if (!response.ok)
				return reply.code(response.status).send({ message: 'Failed to update password.' });

			return reply.code(200).send({ message: 'Password updated successfully.' });

		} catch (error) {
			serv.log.error(`[BFF] Password update error: ${error}`);
			return reply.code(503).send({ message: 'A backend service is unavailable.' });
		}
	});

	serv.post('/account/register', async (request, reply) => {
		let newAccountId: number | null = null;
		try {
			const { username, password } = request.body as { username: string, password: string };

			if (!username || !password)
				return (reply.code(400).send({ message: 'Missing username or password.' }));

			const hashedPassword = await bcrypt.hash(password, 10);

			const accountResponse = await fetch('http://account:3000/internal/account/register', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ username, hashedPassword })
			});

			if (!accountResponse.ok)
				return (reply.code(accountResponse.status).send(await accountResponse.json()));

			const newAccount = await accountResponse.json() as { userID: number, username: string };
			newAccountId = newAccount.userID;

			const profileResponse = await fetch(`http://users:3000/internal/users/${newAccountId}/profile`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ username: newAccount.username })
			});

			if (!profileResponse.ok)
				throw (new Error('Profile creation failed.'));

			return (reply.code(201).send({ message: 'Account and profile created successfully!' }));

		} catch (error) {
			serv.log.error(`[BFF] Error during registration: ${error}`);
			// If the profile creation failed after the account was created, we delete the account.
			if (newAccountId) {
				serv.log.warn(`Rolling back account creation for userID: ${newAccountId}`);
				await fetch(`http://account:3000/internal/accounts/${newAccountId}`, {
					method: 'DELETE'
				});
			}
			return (reply.code(503).send({ message: 'A backend service failed during registration.' }));
		}
	});

	//TOOD: delete account
}
import type { FastifyInstance } from 'fastify';
import type { FriendProfileCard } from './gateway.interface.js';

import { findUserByUsername } from './gatewayFriends.service.js';
import { createFriendRequest } from './gatewayFriends.service.js';
import { acceptFriendRequest } from './gatewayFriends.service.js';
import { deleteFriendRequest } from './gatewayFriends.service.js';
import { fetchRawFriends } from './gatewayFriends.service.js';
import { fetchRawFriendRequests } from './gatewayFriends.service.js';
import { fetchUserProfiles } from './gatewayFriends.service.js';

export async function gatewayFriendRoutes(serv: FastifyInstance) {

	serv.post('/friends/sendrequest', async (request, reply) => {
		try {
			const senderID = request.user.userID;
			const senderUsername = request.user.username;

			const { username: friendUsername } = request.body as { username: string };

			if (!friendUsername)
				return reply.code(400).send({ message: 'Missing friend username in request body.' });

			if (senderUsername === friendUsername)
				return reply.code(400).send({ message: 'You cannot send a friend request to yourself.' });

			const friendUser = await findUserByUsername(friendUsername);
			if (!friendUser)
				return reply.code(404).send({ message: `User '${friendUsername}' not found.` });

			const friendsServiceResponse = await createFriendRequest(senderID, friendUser.userID);
			return (reply
				.code(friendsServiceResponse.status)
				.send(await friendsServiceResponse.json()));

		} catch (error) {
			serv.log.error(`[BFF] Error sending friend request: ${error}`);
			return reply.code(503).send({ message: 'A backend service is currently unavailable.' });
		}
	});

	serv.patch('/friends/acceptrequest', async (request, reply) => {
		try {
			const receiverID = request.user.userID;
			const receiverUsername = request.user.username;

			const { username: senderRequestUsername } = request.body as { username: string };

			if (!senderRequestUsername)
				return reply.code(400).send({ message: 'Missing friend username in request body.' });

			if (senderRequestUsername === receiverUsername)
				return reply.code(400).send({ message: 'You cannot accept a friend request to yourself.' });

			const senderRequestUser = await findUserByUsername(senderRequestUsername);
			if (!senderRequestUser)
				return reply.code(404).send({ message: `User '${senderRequestUsername}' not found.` });

			const friendsServiceResponse = await acceptFriendRequest(receiverID, senderRequestUser.userID);
			return (reply
				.code(friendsServiceResponse.status)
				.send(await friendsServiceResponse.json()));

		} catch (error) {
			serv.log.error(`[BFF] Error accepting friend request: ${error}`);
			return reply.code(503).send({ message: 'A backend service is currently unavailable.' });
		}
	});

	serv.delete('/friends/deletefriendship', async (request, reply) => {
		try {
			const removerID = request.user.userID;
			const removerUsername = request.user.username;

			const { username: friendUsername } = request.body as { username: string };

			if (!friendUsername)
				return reply.code(400).send({ message: 'Missing friend username in request body.' });

			if (friendUsername === removerUsername)
				return reply.code(400).send({ message: 'You cannot accept a friend request to yourself.' });

			const friendUser = await findUserByUsername(friendUsername);
			if (!friendUser)
				return reply.code(404).send({ message: `User '${friendUsername}' not found.` });

			const friendsServiceResponse = await deleteFriendRequest(removerID, friendUser.userID);
			return (reply
				.code(friendsServiceResponse.status)
				.send(await friendsServiceResponse.json()));

		} catch (error) {
			serv.log.error(`[BFF] Error deleting friend request: ${error}`);
			return reply.code(503).send({ message: 'A backend service is currently unavailable.' });
		}
	});

	serv.get('/friends/friendlist', async (request, reply) => {
		try {
			const userID = request.user.userID;

			const friends = await fetchRawFriends(userID);
			if (friends.length === 0)
				return (reply.code(200).send([]));

			const friendIDs = friends.map(friend => friend.otherUserID);
			const profiles = await fetchUserProfiles(friendIDs);
			const profilesMap = new Map(profiles.map(p => [p.userID, p]));

			const friendCards = friends.map((friend): FriendProfileCard | null => {
				const profile = profilesMap.get(friend.otherUserID);
				if (!profile)
					return (null);

				return {
					username: profile.username,
					avatar: profile.avatar,
					biography: profile.biography,
					friendship: {
						friendsSince: friend.startTime,
					},
				};
			}).filter((card): card is FriendProfileCard => card !== null);

			return (reply.code(200).send(friendCards));

		} catch (error) {
			serv.log.error(`[BFF] Error fetching friends list: ${error}`);
			return (reply.code(503).send({ message: 'A backend service is currently unavailable.' }));
		}
	});

	serv.get('/friends/requestlist', async (request, reply) => {
		try {
			const userID = request.user.userID;

			const requests = await fetchRawFriendRequests(userID);
			if (requests.length === 0)
				return (reply.code(200).send([]));

			const senderIDs = requests.map(req => req.otherUserID);
			const profiles = await fetchUserProfiles(senderIDs);
			const profilesMap = new Map(profiles.map(p => [p.userID, p]));

			const requestCards = requests.map((request): FriendProfileCard | null => {
				const profile = profilesMap.get(request.otherUserID);
				if (!profile)
					return (null);
				return {
					username: profile.username,
					avatar: profile.avatar,
					biography: profile.biography,
					friendship: {
						friendsSince: request.startTime,
					}
				}
			}).filter((card): card is FriendProfileCard => card !== null);

			return (reply.code(200).send(requestCards));

		} catch (error) {
			serv.log.error(`[BFF] Error fetching friend request list: ${error}`);
			return reply.code(503).send({ message: 'A backend service is currently unavailable.' });
		}
	});
}



import type { FastifyInstance } from 'fastify';
import { findUserByUsername } from './gatewayFriends.service.js';

import { fetchUserStats } from './gatewayStats.service.js';
import { updateUserStats } from './gatewayStats.service.js';
import { incrementWinStreak } from './gatewayStats.service.js';
import { resetWinStreak } from './gatewayStats.service.js';

export async function gatewayStatsRoutes(serv: FastifyInstance) {

	serv.get('/api/users/:username/stats', async (request, reply) => {
		try {
			const { username } = request.params as { username: string };

			const user = await findUserByUsername(username);
			if (!user)
				return reply.code(404).send({ message: `User '${username}' not found.` });

			const statsResponse = await fetchUserStats(user.userID);

			return reply.code(statsResponse.status).send(await statsResponse.json());

		} catch (error) {
			serv.log.error(`[BFF] Error getting user stats: ${error}`);
			return reply.code(503).send({ message: 'A backend service is unavailable.' });
		}
	});

	serv.get('/api/account/me/stats', async (request, reply) => {
		try {
			const userID = request.user.userID;

			const statsResponse = await fetchUserStats(userID);

			return reply.code(statsResponse.status).send(await statsResponse.json());

		} catch (error) {
			serv.log.error(`[BFF] Error getting own stats: ${error}`);
			return reply.code(503).send({ message: 'A backend service is unavailable.' });
		}
	});

	serv.post('/api/games/results', async (request, reply) => {
		try {
			const { winnerID, loserID, duration, winnerScore } = request.body as any;

			const winnerActions = [
				{ action: 'increment', field: 'totalMatch', value: 1 },
				{ action: 'increment', field: 'totalWins', value: 1 },
				{ action: 'setIfGreater', field: 'longestMatch', value: duration },
				{ action: 'setIfLess', field: 'shortestMatch', value: duration },
				{ action: 'setIfGreater', field: 'highestScore', value: winnerScore }
			];

			const loserActions = [
				{ action: 'increment', field: 'totalMatch', value: 1 },
				{ action: 'setIfGreater', field: 'longestMatch', value: duration },
				{ action: 'setIfLess', field: 'shortestMatch', value: duration }
			];

			await Promise.all([
				updateUserStats(winnerID, winnerActions),
				incrementWinStreak(winnerID),

				updateUserStats(loserID, loserActions),
				resetWinStreak(loserID)
			]);

			return reply.code(200).send({ message: 'Game results processed.' });
		} catch (error) {
			serv.log.error(`[BFF] Error processing game results: ${error}`);
			return reply.code(503).send({ message: 'A backend service is unavailable.' });
		}
	});
}
import { info } from 'console';
import type { FastifyInstance } from 'fastify';

import type { UserCard } from './gateway.interface.js';
import type { RawUserProfile } from './gateway.interface.js';
import type { RawUserStats } from './gateway.interface.js';
import type { RawUserActivity } from './gateway.interface.js';
import type { FriendshipStatus } from './gateway.interface.js';

import { fetchFriendshipStatus } from './gatewayUser.service.js'

/*create user card
modify all user card info individualy
get userID by username 
get username by userID
get status user

export interface UserData {
	avatar: ImgMetadata;
	biography: string;
	relation: ProfileView;
	status: boolean;
	username: string;
	id: string;
	winstreak: string;
}*/

import dns from 'dns';
import fs from 'fs';

function getNginxIP(): string | null {
  const ip: string | undefined = process.env.NGINXIP;
  if (ip === undefined)
    throw new Error('NGINXIP is undefined');
  dns.lookup(ip, (err, address) => {
    if (err)
      throw new Error('failed to resolve nginx IP address');
    return address;
  });
  return null;
}

function checkProxy(address: string, hop: number): boolean {
  const nginxIP = getNginxIP();
  if (address === nginxIP && hop === 1)
    return true;
  return false;
}

const options = {
  logger: {
    file: '/usr/app/server.log'
  },
  trustProxy: checkProxy,
  https: {
    key: fs.readFileSync('/run/secrets/ssl-key.pem'),
    cert: fs.readFileSync('/run/secrets/ssl-cert.pem'),
  }
  //connectionTimeout
  //forceCloseConnections
  //pluginTimeout
}

export { options };import 'fastify';

declare module 'fastify' {
	export interface FastifyRequest {
		user: {
			userID: number;
			username: string;
		};
	}
}import Fastify from 'fastify'
import type { FastifyInstance } from 'fastify';
import cors from '@fastify/cors';
import { gatewayFriendRoutes } from './routeFriends.js';
import { gatewayStatsRoutes } from './routeStats.js';
import { gatewayAccessibilityRoutes } from './routeAccessibility.js';
import { gatewayAccountRoutes } from './routeAccount.js';
import { options } from './serv.conf.js';

const serv: FastifyInstance = Fastify(options);

serv.register(cors, {
	origin: true,
	methods: ['GET', 'POST', 'PUT', 'DELETE']
});

serv.register(gatewayFriendRoutes);
serv.register(gatewayAccessibilityRoutes);
serv.register(gatewayStatsRoutes);
serv.register(gatewayAccountRoutes);

const start = async () => {
	try {
		console.log('listening on 4040');
		await serv.listen({ port: 4040, host: '0.0.0.0' });
	}
	catch (err) {
		console.error('server error:', err);
		process.exit(1);
	}
};

start();
